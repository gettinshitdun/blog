<!DOCTYPE html>
<html lang="en" dir="ltr"><head><title>Exploring Linux Kernel's Process Management</title><meta charset="utf-8"/><link rel="preconnect" href="https://fonts.googleapis.com"/><link rel="preconnect" href="https://fonts.gstatic.com"/><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Montserrat:wght@400;700&amp;family=Source Serif 4:ital,wght@0,400;0,600;1,400;1,600&amp;family=JetBrains Mono:wght@400;600&amp;display=swap"/><link rel="preconnect" href="https://cdnjs.cloudflare.com" crossorigin="anonymous"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><meta name="og:site_name" content="Fish in the sea"/><meta property="og:title" content="Exploring Linux Kernel's Process Management"/><meta property="og:type" content="website"/><meta name="twitter:card" content="summary_large_image"/><meta name="twitter:title" content="Exploring Linux Kernel's Process Management"/><meta name="twitter:description" content="These are all the notes while i am learning the linux kernel’s internals specifically Process Management Currently I am learning these topics will update as i learn more My primary source is the Linux kernel development book Currently this is the topic which i am learning Process Definition Process ..."/><meta property="og:description" content="These are all the notes while i am learning the linux kernel’s internals specifically Process Management Currently I am learning these topics will update as i learn more My primary source is the Linux kernel development book Currently this is the topic which i am learning Process Definition Process ..."/><meta property="og:image:alt" content="These are all the notes while i am learning the linux kernel’s internals specifically Process Management Currently I am learning these topics will update as i learn more My primary source is the Linux kernel development book Currently this is the topic which i am learning Process Definition Process ..."/><meta property="twitter:domain" content="gettinshitdun.github.io"/><meta property="og:url" content="https://gettinshitdun.github.io/Kotia/Exploring-Process-Management---Linux-Kernel-Internals"/><meta property="twitter:url" content="https://gettinshitdun.github.io/Kotia/Exploring-Process-Management---Linux-Kernel-Internals"/><link rel="icon" href="../static/icon.png"/><meta name="description" content="These are all the notes while i am learning the linux kernel’s internals specifically Process Management Currently I am learning these topics will update as i learn more My primary source is the Linux kernel development book Currently this is the topic which i am learning Process Definition Process ..."/><meta name="generator" content="Quartz"/><link href="../index.css" rel="stylesheet" type="text/css" spa-preserve/><style>.expand-button {
  position: absolute;
  display: flex;
  float: right;
  padding: 0.4rem;
  margin: 0.3rem;
  right: 0;
  color: var(--gray);
  border-color: var(--dark);
  background-color: var(--light);
  border: 1px solid;
  border-radius: 5px;
  opacity: 0;
  transition: 0.2s;
}
.expand-button > svg {
  fill: var(--light);
  filter: contrast(0.3);
}
.expand-button:hover {
  cursor: pointer;
  border-color: var(--secondary);
}
.expand-button:focus {
  outline: 0;
}

pre:hover > .expand-button {
  opacity: 1;
  transition: 0.2s;
}

#mermaid-container {
  position: fixed;
  contain: layout;
  z-index: 999;
  left: 0;
  top: 0;
  width: 100vw;
  height: 100vh;
  overflow: hidden;
  display: none;
  backdrop-filter: blur(4px);
  background: rgba(0, 0, 0, 0.5);
}
#mermaid-container.active {
  display: inline-block;
}
#mermaid-container > #mermaid-space {
  border: 1px solid var(--lightgray);
  background-color: var(--light);
  border-radius: 5px;
  position: fixed;
  top: 50%;
  left: 50%;
  transform: translate(-50%, -50%);
  height: 80vh;
  width: 80vw;
  overflow: hidden;
}
#mermaid-container > #mermaid-space > .mermaid-content {
  padding: 2rem;
  position: relative;
  transform-origin: 0 0;
  transition: transform 0.1s ease;
  overflow: visible;
  min-height: 200px;
  min-width: 200px;
}
#mermaid-container > #mermaid-space > .mermaid-content pre {
  margin: 0;
  border: none;
}
#mermaid-container > #mermaid-space > .mermaid-content svg {
  max-width: none;
  height: auto;
}
#mermaid-container > #mermaid-space > .mermaid-controls {
  position: absolute;
  bottom: 20px;
  right: 20px;
  display: flex;
  gap: 8px;
  padding: 8px;
  background: var(--light);
  border: 1px solid var(--lightgray);
  border-radius: 6px;
  box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
  z-index: 2;
}
#mermaid-container > #mermaid-space > .mermaid-controls .mermaid-control-button {
  display: flex;
  align-items: center;
  justify-content: center;
  width: 32px;
  height: 32px;
  padding: 0;
  border: 1px solid var(--lightgray);
  background: var(--light);
  color: var(--dark);
  border-radius: 4px;
  cursor: pointer;
  font-size: 16px;
  font-family: var(--bodyFont);
  transition: all 0.2s ease;
}
#mermaid-container > #mermaid-space > .mermaid-controls .mermaid-control-button:hover {
  background: var(--lightgray);
}
#mermaid-container > #mermaid-space > .mermaid-controls .mermaid-control-button:active {
  transform: translateY(1px);
}
#mermaid-container > #mermaid-space > .mermaid-controls .mermaid-control-button:nth-child(2) {
  width: auto;
  padding: 0 12px;
  font-size: 14px;
}
/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VSb290IjoiL2hvbWUvcGFydGgvYmxvZy9xdWFydHovY29tcG9uZW50cy9zdHlsZXMiLCJzb3VyY2VzIjpbIm1lcm1haWQuaW5saW5lLnNjc3MiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7RUFDRTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTs7QUFFQTtFQUNFO0VBQ0E7O0FBR0Y7RUFDRTtFQUNBOztBQUdGO0VBQ0U7OztBQUtGO0VBQ0U7RUFDQTs7O0FBSUo7RUFDRTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBOztBQUVBO0VBQ0U7O0FBR0Y7RUFDRTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTs7QUFFQTtFQUNFO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBOztBQUVBO0VBQ0U7RUFDQTs7QUFHRjtFQUNFO0VBQ0E7O0FBSUo7RUFDRTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBOztBQUVBO0VBQ0U7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTs7QUFFQTtFQUNFOztBQUdGO0VBQ0U7O0FBSUY7RUFDRTtFQUNBO0VBQ0EiLCJzb3VyY2VzQ29udGVudCI6WyIuZXhwYW5kLWJ1dHRvbiB7XG4gIHBvc2l0aW9uOiBhYnNvbHV0ZTtcbiAgZGlzcGxheTogZmxleDtcbiAgZmxvYXQ6IHJpZ2h0O1xuICBwYWRkaW5nOiAwLjRyZW07XG4gIG1hcmdpbjogMC4zcmVtO1xuICByaWdodDogMDsgLy8gTk9URTogcmlnaHQgd2lsbCBiZSBzZXQgaW4gbWVybWFpZC5pbmxpbmUudHNcbiAgY29sb3I6IHZhcigtLWdyYXkpO1xuICBib3JkZXItY29sb3I6IHZhcigtLWRhcmspO1xuICBiYWNrZ3JvdW5kLWNvbG9yOiB2YXIoLS1saWdodCk7XG4gIGJvcmRlcjogMXB4IHNvbGlkO1xuICBib3JkZXItcmFkaXVzOiA1cHg7XG4gIG9wYWNpdHk6IDA7XG4gIHRyYW5zaXRpb246IDAuMnM7XG5cbiAgJiA+IHN2ZyB7XG4gICAgZmlsbDogdmFyKC0tbGlnaHQpO1xuICAgIGZpbHRlcjogY29udHJhc3QoMC4zKTtcbiAgfVxuXG4gICY6aG92ZXIge1xuICAgIGN1cnNvcjogcG9pbnRlcjtcbiAgICBib3JkZXItY29sb3I6IHZhcigtLXNlY29uZGFyeSk7XG4gIH1cblxuICAmOmZvY3VzIHtcbiAgICBvdXRsaW5lOiAwO1xuICB9XG59XG5cbnByZSB7XG4gICY6aG92ZXIgPiAuZXhwYW5kLWJ1dHRvbiB7XG4gICAgb3BhY2l0eTogMTtcbiAgICB0cmFuc2l0aW9uOiAwLjJzO1xuICB9XG59XG5cbiNtZXJtYWlkLWNvbnRhaW5lciB7XG4gIHBvc2l0aW9uOiBmaXhlZDtcbiAgY29udGFpbjogbGF5b3V0O1xuICB6LWluZGV4OiA5OTk7XG4gIGxlZnQ6IDA7XG4gIHRvcDogMDtcbiAgd2lkdGg6IDEwMHZ3O1xuICBoZWlnaHQ6IDEwMHZoO1xuICBvdmVyZmxvdzogaGlkZGVuO1xuICBkaXNwbGF5OiBub25lO1xuICBiYWNrZHJvcC1maWx0ZXI6IGJsdXIoNHB4KTtcbiAgYmFja2dyb3VuZDogcmdiYSgwLCAwLCAwLCAwLjUpO1xuXG4gICYuYWN0aXZlIHtcbiAgICBkaXNwbGF5OiBpbmxpbmUtYmxvY2s7XG4gIH1cblxuICAmID4gI21lcm1haWQtc3BhY2Uge1xuICAgIGJvcmRlcjogMXB4IHNvbGlkIHZhcigtLWxpZ2h0Z3JheSk7XG4gICAgYmFja2dyb3VuZC1jb2xvcjogdmFyKC0tbGlnaHQpO1xuICAgIGJvcmRlci1yYWRpdXM6IDVweDtcbiAgICBwb3NpdGlvbjogZml4ZWQ7XG4gICAgdG9wOiA1MCU7XG4gICAgbGVmdDogNTAlO1xuICAgIHRyYW5zZm9ybTogdHJhbnNsYXRlKC01MCUsIC01MCUpO1xuICAgIGhlaWdodDogODB2aDtcbiAgICB3aWR0aDogODB2dztcbiAgICBvdmVyZmxvdzogaGlkZGVuO1xuXG4gICAgJiA+IC5tZXJtYWlkLWNvbnRlbnQge1xuICAgICAgcGFkZGluZzogMnJlbTtcbiAgICAgIHBvc2l0aW9uOiByZWxhdGl2ZTtcbiAgICAgIHRyYW5zZm9ybS1vcmlnaW46IDAgMDtcbiAgICAgIHRyYW5zaXRpb246IHRyYW5zZm9ybSAwLjFzIGVhc2U7XG4gICAgICBvdmVyZmxvdzogdmlzaWJsZTtcbiAgICAgIG1pbi1oZWlnaHQ6IDIwMHB4O1xuICAgICAgbWluLXdpZHRoOiAyMDBweDtcblxuICAgICAgcHJlIHtcbiAgICAgICAgbWFyZ2luOiAwO1xuICAgICAgICBib3JkZXI6IG5vbmU7XG4gICAgICB9XG5cbiAgICAgIHN2ZyB7XG4gICAgICAgIG1heC13aWR0aDogbm9uZTtcbiAgICAgICAgaGVpZ2h0OiBhdXRvO1xuICAgICAgfVxuICAgIH1cblxuICAgICYgPiAubWVybWFpZC1jb250cm9scyB7XG4gICAgICBwb3NpdGlvbjogYWJzb2x1dGU7XG4gICAgICBib3R0b206IDIwcHg7XG4gICAgICByaWdodDogMjBweDtcbiAgICAgIGRpc3BsYXk6IGZsZXg7XG4gICAgICBnYXA6IDhweDtcbiAgICAgIHBhZGRpbmc6IDhweDtcbiAgICAgIGJhY2tncm91bmQ6IHZhcigtLWxpZ2h0KTtcbiAgICAgIGJvcmRlcjogMXB4IHNvbGlkIHZhcigtLWxpZ2h0Z3JheSk7XG4gICAgICBib3JkZXItcmFkaXVzOiA2cHg7XG4gICAgICBib3gtc2hhZG93OiAwIDJweCA0cHggcmdiYSgwLCAwLCAwLCAwLjEpO1xuICAgICAgei1pbmRleDogMjtcblxuICAgICAgLm1lcm1haWQtY29udHJvbC1idXR0b24ge1xuICAgICAgICBkaXNwbGF5OiBmbGV4O1xuICAgICAgICBhbGlnbi1pdGVtczogY2VudGVyO1xuICAgICAgICBqdXN0aWZ5LWNvbnRlbnQ6IGNlbnRlcjtcbiAgICAgICAgd2lkdGg6IDMycHg7XG4gICAgICAgIGhlaWdodDogMzJweDtcbiAgICAgICAgcGFkZGluZzogMDtcbiAgICAgICAgYm9yZGVyOiAxcHggc29saWQgdmFyKC0tbGlnaHRncmF5KTtcbiAgICAgICAgYmFja2dyb3VuZDogdmFyKC0tbGlnaHQpO1xuICAgICAgICBjb2xvcjogdmFyKC0tZGFyayk7XG4gICAgICAgIGJvcmRlci1yYWRpdXM6IDRweDtcbiAgICAgICAgY3Vyc29yOiBwb2ludGVyO1xuICAgICAgICBmb250LXNpemU6IDE2cHg7XG4gICAgICAgIGZvbnQtZmFtaWx5OiB2YXIoLS1ib2R5Rm9udCk7XG4gICAgICAgIHRyYW5zaXRpb246IGFsbCAwLjJzIGVhc2U7XG5cbiAgICAgICAgJjpob3ZlciB7XG4gICAgICAgICAgYmFja2dyb3VuZDogdmFyKC0tbGlnaHRncmF5KTtcbiAgICAgICAgfVxuXG4gICAgICAgICY6YWN0aXZlIHtcbiAgICAgICAgICB0cmFuc2Zvcm06IHRyYW5zbGF0ZVkoMXB4KTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFN0eWxlIHRoZSByZXNldCBidXR0b24gZGlmZmVyZW50bHlcbiAgICAgICAgJjpudGgtY2hpbGQoMikge1xuICAgICAgICAgIHdpZHRoOiBhdXRvO1xuICAgICAgICAgIHBhZGRpbmc6IDAgMTJweDtcbiAgICAgICAgICBmb250LXNpemU6IDE0cHg7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cbiJdfQ== */</style><link href="https://cdn.jsdelivr.net/npm/katex@0.16.11/dist/katex.min.css" rel="stylesheet" type="text/css" spa-preserve/><script src="../prescript.js" type="application/javascript" spa-preserve></script><script type="application/javascript" spa-preserve>const fetchData = fetch("../static/contentIndex.json").then(data => data.json())</script><meta property="og:image:width" content="1200"/><meta property="og:image:height" content="630"/><meta property="og:image" content="https://gettinshitdun.github.io/Kotia/Exploring-Process-Management---Linux-Kernel-Internals-og-image.webp"/><meta property="og:image:url" content="https://gettinshitdun.github.io/Kotia/Exploring-Process-Management---Linux-Kernel-Internals-og-image.webp"/><meta name="twitter:image" content="https://gettinshitdun.github.io/Kotia/Exploring-Process-Management---Linux-Kernel-Internals-og-image.webp"/><meta property="og:image:type" content="image/.webp"/></head><body data-slug="Kotia/Exploring-Process-Management---Linux-Kernel-Internals"><div id="quartz-root" class="page"><div id="quartz-body"><div class="left sidebar"><h2 class="page-title"><a href="..">Fish in the sea</a></h2><div class="spacer mobile-only"></div><div class="flex-component" style="flex-direction: row; flex-wrap: nowrap; gap: 1rem;"><div style="flex-grow: 1; flex-shrink: 1; flex-basis: auto; order: 0; align-self: center; justify-self: center;"><div class="search"><button class="search-button"><svg role="img" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 19.9 19.7"><title>Search</title><g class="search-path" fill="none"><path stroke-linecap="square" d="M18.5 18.3l-5.4-5.4"></path><circle cx="8" cy="8" r="7"></circle></g></svg><p>Search</p></button><div class="search-container"><div class="search-space"><input autocomplete="off" class="search-bar" name="search" type="text" aria-label="Search for something" placeholder="Search for something"/><div class="search-layout" data-preview="true"></div></div></div></div></div><div style="flex-grow: 0; flex-shrink: 1; flex-basis: auto; order: 0; align-self: center; justify-self: center;"><button class="darkmode"><svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" version="1.1" class="dayIcon" x="0px" y="0px" viewBox="0 0 35 35" style="enable-background:new 0 0 35 35" xml:space="preserve" aria-label="Dark mode"><title>Dark mode</title><path d="M6,17.5C6,16.672,5.328,16,4.5,16h-3C0.672,16,0,16.672,0,17.5    S0.672,19,1.5,19h3C5.328,19,6,18.328,6,17.5z M7.5,26c-0.414,0-0.789,0.168-1.061,0.439l-2,2C4.168,28.711,4,29.086,4,29.5    C4,30.328,4.671,31,5.5,31c0.414,0,0.789-0.168,1.06-0.44l2-2C8.832,28.289,9,27.914,9,27.5C9,26.672,8.329,26,7.5,26z M17.5,6    C18.329,6,19,5.328,19,4.5v-3C19,0.672,18.329,0,17.5,0S16,0.672,16,1.5v3C16,5.328,16.671,6,17.5,6z M27.5,9    c0.414,0,0.789-0.168,1.06-0.439l2-2C30.832,6.289,31,5.914,31,5.5C31,4.672,30.329,4,29.5,4c-0.414,0-0.789,0.168-1.061,0.44    l-2,2C26.168,6.711,26,7.086,26,7.5C26,8.328,26.671,9,27.5,9z M6.439,8.561C6.711,8.832,7.086,9,7.5,9C8.328,9,9,8.328,9,7.5    c0-0.414-0.168-0.789-0.439-1.061l-2-2C6.289,4.168,5.914,4,5.5,4C4.672,4,4,4.672,4,5.5c0,0.414,0.168,0.789,0.439,1.06    L6.439,8.561z M33.5,16h-3c-0.828,0-1.5,0.672-1.5,1.5s0.672,1.5,1.5,1.5h3c0.828,0,1.5-0.672,1.5-1.5S34.328,16,33.5,16z     M28.561,26.439C28.289,26.168,27.914,26,27.5,26c-0.828,0-1.5,0.672-1.5,1.5c0,0.414,0.168,0.789,0.439,1.06l2,2    C28.711,30.832,29.086,31,29.5,31c0.828,0,1.5-0.672,1.5-1.5c0-0.414-0.168-0.789-0.439-1.061L28.561,26.439z M17.5,29    c-0.829,0-1.5,0.672-1.5,1.5v3c0,0.828,0.671,1.5,1.5,1.5s1.5-0.672,1.5-1.5v-3C19,29.672,18.329,29,17.5,29z M17.5,7    C11.71,7,7,11.71,7,17.5S11.71,28,17.5,28S28,23.29,28,17.5S23.29,7,17.5,7z M17.5,25c-4.136,0-7.5-3.364-7.5-7.5    c0-4.136,3.364-7.5,7.5-7.5c4.136,0,7.5,3.364,7.5,7.5C25,21.636,21.636,25,17.5,25z"></path></svg><svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" version="1.1" class="nightIcon" x="0px" y="0px" viewBox="0 0 100 100" style="enable-background:new 0 0 100 100" xml:space="preserve" aria-label="Light mode"><title>Light mode</title><path d="M96.76,66.458c-0.853-0.852-2.15-1.064-3.23-0.534c-6.063,2.991-12.858,4.571-19.655,4.571  C62.022,70.495,50.88,65.88,42.5,57.5C29.043,44.043,25.658,23.536,34.076,6.47c0.532-1.08,0.318-2.379-0.534-3.23  c-0.851-0.852-2.15-1.064-3.23-0.534c-4.918,2.427-9.375,5.619-13.246,9.491c-9.447,9.447-14.65,22.008-14.65,35.369  c0,13.36,5.203,25.921,14.65,35.368s22.008,14.65,35.368,14.65c13.361,0,25.921-5.203,35.369-14.65  c3.872-3.871,7.064-8.328,9.491-13.246C97.826,68.608,97.611,67.309,96.76,66.458z"></path></svg></button></div><div style="flex-grow: 0; flex-shrink: 1; flex-basis: auto; order: 0; align-self: center; justify-self: center;"><button class="readermode"><svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" version="1.1" class="readerIcon" fill="currentColor" stroke="currentColor" stroke-width="0.2" stroke-linecap="round" stroke-linejoin="round" width="64px" height="64px" viewBox="0 0 24 24" aria-label="Reader mode"><title>Reader mode</title><g transform="translate(-1.8, -1.8) scale(1.15, 1.2)"><path d="M8.9891247,2.5 C10.1384702,2.5 11.2209868,2.96705384 12.0049645,3.76669482 C12.7883914,2.96705384 13.8709081,2.5 15.0202536,2.5 L18.7549359,2.5 C19.1691495,2.5 19.5049359,2.83578644 19.5049359,3.25 L19.5046891,4.004 L21.2546891,4.00457396 C21.6343849,4.00457396 21.9481801,4.28672784 21.9978425,4.6528034 L22.0046891,4.75457396 L22.0046891,20.25 C22.0046891,20.6296958 21.7225353,20.943491 21.3564597,20.9931534 L21.2546891,21 L2.75468914,21 C2.37499337,21 2.06119817,20.7178461 2.01153575,20.3517706 L2.00468914,20.25 L2.00468914,4.75457396 C2.00468914,4.37487819 2.28684302,4.061083 2.65291858,4.01142057 L2.75468914,4.00457396 L4.50368914,4.004 L4.50444233,3.25 C4.50444233,2.87030423 4.78659621,2.55650904 5.15267177,2.50684662 L5.25444233,2.5 L8.9891247,2.5 Z M4.50368914,5.504 L3.50468914,5.504 L3.50468914,19.5 L10.9478955,19.4998273 C10.4513189,18.9207296 9.73864328,18.5588115 8.96709342,18.5065584 L8.77307039,18.5 L5.25444233,18.5 C4.87474657,18.5 4.56095137,18.2178461 4.51128895,17.8517706 L4.50444233,17.75 L4.50368914,5.504 Z M19.5049359,17.75 C19.5049359,18.1642136 19.1691495,18.5 18.7549359,18.5 L15.2363079,18.5 C14.3910149,18.5 13.5994408,18.8724714 13.0614828,19.4998273 L20.5046891,19.5 L20.5046891,5.504 L19.5046891,5.504 L19.5049359,17.75 Z M18.0059359,3.999 L15.0202536,4 L14.8259077,4.00692283 C13.9889509,4.06666544 13.2254227,4.50975805 12.7549359,5.212 L12.7549359,17.777 L12.7782651,17.7601316 C13.4923805,17.2719483 14.3447024,17 15.2363079,17 L18.0059359,16.999 L18.0056891,4.798 L18.0033792,4.75457396 L18.0056891,4.71 L18.0059359,3.999 Z M8.9891247,4 L6.00368914,3.999 L6.00599909,4.75457396 L6.00599909,4.75457396 L6.00368914,4.783 L6.00368914,16.999 L8.77307039,17 C9.57551536,17 10.3461406,17.2202781 11.0128313,17.6202194 L11.2536891,17.776 L11.2536891,5.211 C10.8200889,4.56369974 10.1361548,4.13636104 9.37521067,4.02745763 L9.18347055,4.00692283 L8.9891247,4 Z"></path></g></svg></button></div></div><div class="explorer" data-behavior="link" data-collapsed="collapsed" data-savestate="true" data-data-fns="{&quot;order&quot;:[&quot;filter&quot;,&quot;map&quot;,&quot;sort&quot;],&quot;sortFn&quot;:&quot;(a,b)=>!a.isFolder&amp;&amp;!b.isFolder||a.isFolder&amp;&amp;b.isFolder?a.displayName.localeCompare(b.displayName,void 0,{numeric:!0,sensitivity:\&quot;base\&quot;}):!a.isFolder&amp;&amp;b.isFolder?1:-1&quot;,&quot;filterFn&quot;:&quot;node=>node.slugSegment!==\&quot;tags\&quot;&quot;,&quot;mapFn&quot;:&quot;node=>node&quot;}"><button type="button" class="explorer-toggle mobile-explorer hide-until-loaded" data-mobile="true" aria-controls="explorer-0"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="lucide-menu"><line x1="4" x2="20" y1="12" y2="12"></line><line x1="4" x2="20" y1="6" y2="6"></line><line x1="4" x2="20" y1="18" y2="18"></line></svg></button><button type="button" class="title-button explorer-toggle desktop-explorer" data-mobile="false" aria-expanded="true"><h2>Explorer</h2><svg xmlns="http://www.w3.org/2000/svg" width="14" height="14" viewBox="5 8 14 8" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="fold"><polyline points="6 9 12 15 18 9"></polyline></svg></button><div id="explorer-0" class="explorer-content" aria-expanded="false" role="group"><ul class="explorer-ul overflow" id="list-0"><li class="overflow-end"></li></ul></div><template id="template-file"><li><a href="#"></a></li></template><template id="template-folder"><li><div class="folder-container"><svg xmlns="http://www.w3.org/2000/svg" width="12" height="12" viewBox="5 8 14 8" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="folder-icon"><polyline points="6 9 12 15 18 9"></polyline></svg><div><button class="folder-button"><span class="folder-title"></span></button></div></div><div class="folder-outer"><ul class="content"></ul></div></li></template></div></div><div class="center"><div class="page-header"><div class="popover-hint"><nav class="breadcrumb-container" aria-label="breadcrumbs"><div class="breadcrumb-element"><a href="../">Home</a><p> ❯ </p></div><div class="breadcrumb-element"><a href="../Kotia/">Kotia</a><p> ❯ </p></div><div class="breadcrumb-element"><a href>Exploring Linux Kernel's Process Management</a></div></nav><h1 class="article-title">Exploring Linux Kernel's Process Management</h1><p show-comma="true" class="content-meta"><time datetime="2025-09-28T14:26:11.000Z">Sep 28, 2025</time><span>16 min read</span></p></div></div><article class="popover-hint"><p>These are all the notes while i am learning the linux kernel’s internals specifically Process Management</p>
<p>Currently I am learning these topics will update as i learn more</p>
<p>My primary source is the Linux kernel development book</p>
<p>Currently this is the topic which i am learning</p>
<ul>
<li>
<p>Process Definition</p>
</li>
<li>
<p>Process descriptor code</p>
</li>
<li>
<p>fork(), exec() what do they do and how do they work?</p>
</li>
</ul>
<h1 id="process-definition">Process Definition<a role="anchor" aria-hidden="true" tabindex="-1" data-no-popover="true" href="#process-definition" class="internal"><svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71"></path><path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71"></path></svg></a></h1>
<p>A process is a program (a.out code)in the midst of execution<br/>
Process also includes a set of resources such as open files and pending signals,
internal kernel data, processor state, a memory address space with one or more memory
mappings, one or more threads of execution, and a data section containing global variables.<br/>
Processes, in effect, are the living result of running program code. The kernel needs to
manage all these details efficiently and transparently<br/>
Threads of execution, often shortened to threads, are the objects of activity within the
process.<br/>
Each thread includes a unique program counter, process stack, and set of proces-
sor registers.<br/>
The kernel schedules individual threads, not processes. In traditional Unix systems, each process consists of one thread.<br/>
Linux has a unique implementation of threads: It does not differentiate between threads and processes.To Linux, a thread is just a special kind of process<br/>
note that threads share the virtual memory abstraction, whereas each
receives its own virtualized processor.<br/>
A program itself is not a process; a process is an active program and related resources. Indeed, two or more processes can exist that are executing the same program. In fact, two or more processes can exist that share various resources, such as open files or an address space.\
The process that calls fork() is the parent, whereas the new process is the child. The parent resumes execution and the child starts execution at the same place: where the call to fork() returns.The fork() system call returns from the kernel twice: once in the parent process and again in the newborn child.<br/>
Often, immediately after a fork it is desirable to execute a new, different program.The exec() family of function calls creates a new address space and loads a new program into it. In contemporary Linux kernels, fork() is actually implemented via the clone() system call, which is discussed in a following section.<br/>
A parent process can inquire about the status of a terminated child via the wait4() system call, which enables a process to wait for the termination of a specific process.When a process exits, it is placed into a special zombie state that represents terminated processes until the parent calls wait() or waitpid().\</p>
<h3 id="note-another-name-for-a-process-is-a-task-the-linux-kernel-internally-refers-to-processes-as-tasks">Note<span>→</span> Another name for a process is a task. The Linux kernel internally refers to processes as tasks.<a role="anchor" aria-hidden="true" tabindex="-1" data-no-popover="true" href="#note-another-name-for-a-process-is-a-task-the-linux-kernel-internally-refers-to-processes-as-tasks" class="internal"><svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71"></path><path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71"></path></svg></a></h3>
<h1 id="fork-workings">fork() workings<a role="anchor" aria-hidden="true" tabindex="-1" data-no-popover="true" href="#fork-workings" class="internal"><svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71"></path><path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71"></path></svg></a></h1>
<p>Need to explore this</p>
<h1 id="process-descriptor-and-task-structure">Process Descriptor and Task Structure<a role="anchor" aria-hidden="true" tabindex="-1" data-no-popover="true" href="#process-descriptor-and-task-structure" class="internal"><svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71"></path><path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71"></path></svg></a></h1>
<p>The kernel stores the list of processes in a circular doubly linked list called the task list(some operating systems also call it as the task array)<br/>
Each element in the task list is a process descriptor of the type struct task_struct, which
is defined in &lt;linux/sched.h>.The process descriptor contains all the information about
a specific process<br/>
The structure contains all the information that the kernel has and needs about a process.The process descriptor contains</p>
<blockquote class="callout note is-collapsible is-collapsed" data-callout="note" data-callout-fold>
<div class="callout-title">
                  <div class="callout-icon"></div>
                  <div class="callout-title-inner"><p>&lt;/include/linux/sched.h> definition of task_struct </p></div>
                  <div class="fold-callout-icon"></div>
                </div>
<div class="callout-content">
<figure data-rehype-pretty-code-figure><pre tabindex="0" data-language="C" data-theme="github-light github-dark"><code data-language="C" data-theme="github-light github-dark" style="display:grid;"><span data-line><span>struct task_struct {</span></span>
<span data-line><span>#ifdef CONFIG_THREAD_INFO_IN_TASK</span></span>
<span data-line><span>	/*</span></span>
<span data-line><span>	 * For reasons of header soup (see current_thread_info()), this</span></span>
<span data-line><span>	 * must be the first element of task_struct.</span></span>
<span data-line><span>	 */</span></span>
<span data-line><span>	struct thread_info		thread_info;</span></span>
<span data-line><span>#endif</span></span>
<span data-line><span>	unsigned int			__state;</span></span>
<span data-line> </span>
<span data-line><span>	/* saved state for &quot;spinlock sleepers&quot; */</span></span>
<span data-line><span>	unsigned int			saved_state;</span></span>
<span data-line> </span>
<span data-line><span>	/*</span></span>
<span data-line><span>	 * This begins the randomizable portion of task_struct. Only</span></span>
<span data-line><span>	 * scheduling-critical items should be added above here.</span></span>
<span data-line><span>	 */</span></span>
<span data-line><span>	randomized_struct_fields_start</span></span>
<span data-line> </span>
<span data-line><span>	void				*stack;</span></span>
<span data-line><span>	refcount_t			usage;</span></span>
<span data-line><span>	/* Per task flags (PF_*), defined further below: */</span></span>
<span data-line><span>	unsigned int			flags;</span></span>
<span data-line><span>	unsigned int			ptrace;</span></span>
<span data-line> </span>
<span data-line><span>#ifdef CONFIG_MEM_ALLOC_PROFILING</span></span>
<span data-line><span>	struct alloc_tag		*alloc_tag;</span></span>
<span data-line><span>#endif</span></span>
<span data-line> </span>
<span data-line><span>	int				on_cpu;</span></span>
<span data-line><span>	struct __call_single_node	wake_entry;</span></span>
<span data-line><span>	unsigned int			wakee_flips;</span></span>
<span data-line><span>	unsigned long			wakee_flip_decay_ts;</span></span>
<span data-line><span>	struct task_struct		*last_wakee;</span></span>
<span data-line> </span>
<span data-line><span>	/*</span></span>
<span data-line><span>	 * recent_used_cpu is initially set as the last CPU used by a task</span></span>
<span data-line><span>	 * that wakes affine another task. Waker/wakee relationships can</span></span>
<span data-line><span>	 * push tasks around a CPU where each wakeup moves to the next one.</span></span>
<span data-line><span>	 * Tracking a recently used CPU allows a quick search for a recently</span></span>
<span data-line><span>	 * used CPU that may be idle.</span></span>
<span data-line><span>	 */</span></span>
<span data-line><span>	int				recent_used_cpu;</span></span>
<span data-line><span>	int				wake_cpu;</span></span>
<span data-line><span>	int				on_rq;</span></span>
<span data-line> </span>
<span data-line><span>	int				prio;</span></span>
<span data-line><span>	int				static_prio;</span></span>
<span data-line><span>	int				normal_prio;</span></span>
<span data-line><span>	unsigned int			rt_priority;</span></span>
<span data-line> </span>
<span data-line><span>	struct sched_entity		se;</span></span>
<span data-line><span>	struct sched_rt_entity		rt;</span></span>
<span data-line><span>	struct sched_dl_entity		dl;</span></span>
<span data-line><span>	struct sched_dl_entity		*dl_server;</span></span>
<span data-line><span>#ifdef CONFIG_SCHED_CLASS_EXT</span></span>
<span data-line><span>	struct sched_ext_entity		scx;</span></span>
<span data-line><span>#endif</span></span>
<span data-line><span>	const struct sched_class	*sched_class;</span></span>
<span data-line> </span>
<span data-line><span>#ifdef CONFIG_SCHED_CORE</span></span>
<span data-line><span>	struct rb_node			core_node;</span></span>
<span data-line><span>	unsigned long			core_cookie;</span></span>
<span data-line><span>	unsigned int			core_occupation;</span></span>
<span data-line><span>#endif</span></span>
<span data-line> </span>
<span data-line><span>#ifdef CONFIG_CGROUP_SCHED</span></span>
<span data-line><span>	struct task_group		*sched_task_group;</span></span>
<span data-line><span>#endif</span></span>
<span data-line> </span>
<span data-line> </span>
<span data-line><span>#ifdef CONFIG_UCLAMP_TASK</span></span>
<span data-line><span>	/*</span></span>
<span data-line><span>	 * Clamp values requested for a scheduling entity.</span></span>
<span data-line><span>	 * Must be updated with task_rq_lock() held.</span></span>
<span data-line><span>	 */</span></span>
<span data-line><span>	struct uclamp_se		uclamp_req[UCLAMP_CNT];</span></span>
<span data-line><span>	/*</span></span>
<span data-line><span>	 * Effective clamp values used for a scheduling entity.</span></span>
<span data-line><span>	 * Must be updated with task_rq_lock() held.</span></span>
<span data-line><span>	 */</span></span>
<span data-line><span>	struct uclamp_se		uclamp[UCLAMP_CNT];</span></span>
<span data-line><span>#endif</span></span>
<span data-line> </span>
<span data-line><span>	struct sched_statistics         stats;</span></span>
<span data-line> </span>
<span data-line><span>#ifdef CONFIG_PREEMPT_NOTIFIERS</span></span>
<span data-line><span>	/* List of struct preempt_notifier: */</span></span>
<span data-line><span>	struct hlist_head		preempt_notifiers;</span></span>
<span data-line><span>#endif</span></span>
<span data-line> </span>
<span data-line><span>#ifdef CONFIG_BLK_DEV_IO_TRACE</span></span>
<span data-line><span>	unsigned int			btrace_seq;</span></span>
<span data-line><span>#endif</span></span>
<span data-line> </span>
<span data-line><span>	unsigned int			policy;</span></span>
<span data-line><span>	unsigned long			max_allowed_capacity;</span></span>
<span data-line><span>	int				nr_cpus_allowed;</span></span>
<span data-line><span>	const cpumask_t			*cpus_ptr;</span></span>
<span data-line><span>	cpumask_t			*user_cpus_ptr;</span></span>
<span data-line><span>	cpumask_t			cpus_mask;</span></span>
<span data-line><span>	void				*migration_pending;</span></span>
<span data-line><span>	unsigned short			migration_disabled;</span></span>
<span data-line><span>	unsigned short			migration_flags;</span></span>
<span data-line> </span>
<span data-line><span>#ifdef CONFIG_PREEMPT_RCU</span></span>
<span data-line><span>	int				rcu_read_lock_nesting;</span></span>
<span data-line><span>	union rcu_special		rcu_read_unlock_special;</span></span>
<span data-line><span>	struct list_head		rcu_node_entry;</span></span>
<span data-line><span>	struct rcu_node			*rcu_blocked_node;</span></span>
<span data-line><span>#endif /* #ifdef CONFIG_PREEMPT_RCU */</span></span>
<span data-line> </span>
<span data-line><span>#ifdef CONFIG_TASKS_RCU</span></span>
<span data-line><span>	unsigned long			rcu_tasks_nvcsw;</span></span>
<span data-line><span>	u8				rcu_tasks_holdout;</span></span>
<span data-line><span>	u8				rcu_tasks_idx;</span></span>
<span data-line><span>	int				rcu_tasks_idle_cpu;</span></span>
<span data-line><span>	struct list_head		rcu_tasks_holdout_list;</span></span>
<span data-line><span>	int				rcu_tasks_exit_cpu;</span></span>
<span data-line><span>	struct list_head		rcu_tasks_exit_list;</span></span>
<span data-line><span>#endif /* #ifdef CONFIG_TASKS_RCU */</span></span>
<span data-line> </span>
<span data-line><span>#ifdef CONFIG_TASKS_TRACE_RCU</span></span>
<span data-line><span>	int				trc_reader_nesting;</span></span>
<span data-line><span>	int				trc_ipi_to_cpu;</span></span>
<span data-line><span>	union rcu_special		trc_reader_special;</span></span>
<span data-line><span>	struct list_head		trc_holdout_list;</span></span>
<span data-line><span>	struct list_head		trc_blkd_node;</span></span>
<span data-line><span>	int				trc_blkd_cpu;</span></span>
<span data-line><span>#endif /* #ifdef CONFIG_TASKS_TRACE_RCU */</span></span>
<span data-line> </span>
<span data-line><span>	struct sched_info		sched_info;</span></span>
<span data-line> </span>
<span data-line><span>	struct list_head		tasks;</span></span>
<span data-line><span>	struct plist_node		pushable_tasks;</span></span>
<span data-line><span>	struct rb_node			pushable_dl_tasks;</span></span>
<span data-line> </span>
<span data-line><span>	struct mm_struct		*mm;</span></span>
<span data-line><span>	struct mm_struct		*active_mm;</span></span>
<span data-line><span>	struct address_space		*faults_disabled_mapping;</span></span>
<span data-line> </span>
<span data-line><span>	int				exit_state;</span></span>
<span data-line><span>	int				exit_code;</span></span>
<span data-line><span>	int				exit_signal;</span></span>
<span data-line><span>	/* The signal sent when the parent dies: */</span></span>
<span data-line><span>	int				pdeath_signal;</span></span>
<span data-line><span>	/* JOBCTL_*, siglock protected: */</span></span>
<span data-line><span>	unsigned long			jobctl;</span></span>
<span data-line> </span>
<span data-line><span>	/* Used for emulating ABI behavior of previous Linux versions: */</span></span>
<span data-line><span>	unsigned int			personality;</span></span>
<span data-line> </span>
<span data-line><span>	/* Scheduler bits, serialized by scheduler locks: */</span></span>
<span data-line><span>	unsigned			sched_reset_on_fork:1;</span></span>
<span data-line><span>	unsigned			sched_contributes_to_load:1;</span></span>
<span data-line><span>	unsigned			sched_migrated:1;</span></span>
<span data-line><span>	unsigned			sched_task_hot:1;</span></span>
<span data-line> </span>
<span data-line><span>	/* Force alignment to the next boundary: */</span></span>
<span data-line><span>	unsigned			:0;</span></span>
<span data-line> </span>
<span data-line><span>	/* Unserialized, strictly 'current' */</span></span>
<span data-line> </span>
<span data-line><span>	/*</span></span>
<span data-line><span>	 * This field must not be in the scheduler word above due to wakelist</span></span>
<span data-line><span>	 * queueing no longer being serialized by p->on_cpu. However:</span></span>
<span data-line><span>	 *</span></span>
<span data-line><span>	 * p->XXX = X;			ttwu()</span></span>
<span data-line><span>	 * schedule()			  if (p->on_rq &amp;&amp; ..) // false</span></span>
<span data-line><span>	 *   smp_mb__after_spinlock();	  if (smp_load_acquire(&amp;p->on_cpu) &amp;&amp; //true</span></span>
<span data-line><span>	 *   deactivate_task()		      ttwu_queue_wakelist())</span></span>
<span data-line><span>	 *     p->on_rq = 0;			p->sched_remote_wakeup = Y;</span></span>
<span data-line><span>	 *</span></span>
<span data-line><span>	 * guarantees all stores of 'current' are visible before</span></span>
<span data-line><span>	 * ->sched_remote_wakeup gets used, so it can be in this word.</span></span>
<span data-line><span>	 */</span></span>
<span data-line><span>	unsigned			sched_remote_wakeup:1;</span></span>
<span data-line><span>#ifdef CONFIG_RT_MUTEXES</span></span>
<span data-line><span>	unsigned			sched_rt_mutex:1;</span></span>
<span data-line><span>#endif</span></span>
<span data-line> </span>
<span data-line><span>	/* Bit to tell TOMOYO we're in execve(): */</span></span>
<span data-line><span>	unsigned			in_execve:1;</span></span>
<span data-line><span>	unsigned			in_iowait:1;</span></span>
<span data-line><span>#ifndef TIF_RESTORE_SIGMASK</span></span>
<span data-line><span>	unsigned			restore_sigmask:1;</span></span>
<span data-line><span>#endif</span></span>
<span data-line><span>#ifdef CONFIG_MEMCG_V1</span></span>
<span data-line><span>	unsigned			in_user_fault:1;</span></span>
<span data-line><span>#endif</span></span>
<span data-line><span>#ifdef CONFIG_LRU_GEN</span></span>
<span data-line><span>	/* whether the LRU algorithm may apply to this access */</span></span>
<span data-line><span>	unsigned			in_lru_fault:1;</span></span>
<span data-line><span>#endif</span></span>
<span data-line><span>#ifdef CONFIG_COMPAT_BRK</span></span>
<span data-line><span>	unsigned			brk_randomized:1;</span></span>
<span data-line><span>#endif</span></span>
<span data-line><span>#ifdef CONFIG_CGROUPS</span></span>
<span data-line><span>	/* disallow userland-initiated cgroup migration */</span></span>
<span data-line><span>	unsigned			no_cgroup_migration:1;</span></span>
<span data-line><span>	/* task is frozen/stopped (used by the cgroup freezer) */</span></span>
<span data-line><span>	unsigned			frozen:1;</span></span>
<span data-line><span>#endif</span></span>
<span data-line><span>#ifdef CONFIG_BLK_CGROUP</span></span>
<span data-line><span>	unsigned			use_memdelay:1;</span></span>
<span data-line><span>#endif</span></span>
<span data-line><span>#ifdef CONFIG_PSI</span></span>
<span data-line><span>	/* Stalled due to lack of memory */</span></span>
<span data-line><span>	unsigned			in_memstall:1;</span></span>
<span data-line><span>#endif</span></span>
<span data-line><span>#ifdef CONFIG_PAGE_OWNER</span></span>
<span data-line><span>	/* Used by page_owner=on to detect recursion in page tracking. */</span></span>
<span data-line><span>	unsigned			in_page_owner:1;</span></span>
<span data-line><span>#endif</span></span>
<span data-line><span>#ifdef CONFIG_EVENTFD</span></span>
<span data-line><span>	/* Recursion prevention for eventfd_signal() */</span></span>
<span data-line><span>	unsigned			in_eventfd:1;</span></span>
<span data-line><span>#endif</span></span>
<span data-line><span>#ifdef CONFIG_ARCH_HAS_CPU_PASID</span></span>
<span data-line><span>	unsigned			pasid_activated:1;</span></span>
<span data-line><span>#endif</span></span>
<span data-line><span>#ifdef CONFIG_X86_BUS_LOCK_DETECT</span></span>
<span data-line><span>	unsigned			reported_split_lock:1;</span></span>
<span data-line><span>#endif</span></span>
<span data-line><span>#ifdef CONFIG_TASK_DELAY_ACCT</span></span>
<span data-line><span>	/* delay due to memory thrashing */</span></span>
<span data-line><span>	unsigned                        in_thrashing:1;</span></span>
<span data-line><span>#endif</span></span>
<span data-line><span>	unsigned			in_nf_duplicate:1;</span></span>
<span data-line><span>#ifdef CONFIG_PREEMPT_RT</span></span>
<span data-line><span>	struct netdev_xmit		net_xmit;</span></span>
<span data-line><span>#endif</span></span>
<span data-line><span>	unsigned long			atomic_flags; /* Flags requiring atomic access. */</span></span>
<span data-line> </span>
<span data-line><span>	struct restart_block		restart_block;</span></span>
<span data-line> </span>
<span data-line><span>	pid_t				pid;</span></span>
<span data-line><span>	pid_t				tgid;</span></span>
<span data-line> </span>
<span data-line><span>#ifdef CONFIG_STACKPROTECTOR</span></span>
<span data-line><span>	/* Canary value for the -fstack-protector GCC feature: */</span></span>
<span data-line><span>	unsigned long			stack_canary;</span></span>
<span data-line><span>#endif</span></span>
<span data-line><span>	/*</span></span>
<span data-line><span>	 * Pointers to the (original) parent process, youngest child, younger sibling,</span></span>
<span data-line><span>	 * older sibling, respectively.  (p->father can be replaced with</span></span>
<span data-line><span>	 * p->real_parent->pid)</span></span>
<span data-line><span>	 */</span></span>
<span data-line> </span>
<span data-line><span>	/* Real parent process: */</span></span>
<span data-line><span>	struct task_struct __rcu	*real_parent;</span></span>
<span data-line> </span>
<span data-line><span>	/* Recipient of SIGCHLD, wait4() reports: */</span></span>
<span data-line><span>	struct task_struct __rcu	*parent;</span></span>
<span data-line> </span>
<span data-line><span>	/*</span></span>
<span data-line><span>	 * Children/sibling form the list of natural children:</span></span>
<span data-line><span>	 */</span></span>
<span data-line><span>	struct list_head		children;</span></span>
<span data-line><span>	struct list_head		sibling;</span></span>
<span data-line><span>	struct task_struct		*group_leader;</span></span>
<span data-line> </span>
<span data-line><span>	/*</span></span>
<span data-line><span>	 * 'ptraced' is the list of tasks this task is using ptrace() on.</span></span>
<span data-line><span>	 *</span></span>
<span data-line><span>	 * This includes both natural children and PTRACE_ATTACH targets.</span></span>
<span data-line><span>	 * 'ptrace_entry' is this task's link on the p->parent->ptraced list.</span></span>
<span data-line><span>	 */</span></span>
<span data-line><span>	struct list_head		ptraced;</span></span>
<span data-line><span>	struct list_head		ptrace_entry;</span></span>
<span data-line> </span>
<span data-line><span>	/* PID/PID hash table linkage. */</span></span>
<span data-line><span>	struct pid			*thread_pid;</span></span>
<span data-line><span>	struct hlist_node		pid_links[PIDTYPE_MAX];</span></span>
<span data-line><span>	struct list_head		thread_node;</span></span>
<span data-line> </span>
<span data-line><span>	struct completion		*vfork_done;</span></span>
<span data-line> </span>
<span data-line><span>	/* CLONE_CHILD_SETTID: */</span></span>
<span data-line><span>	int __user			*set_child_tid;</span></span>
<span data-line> </span>
<span data-line><span>	/* CLONE_CHILD_CLEARTID: */</span></span>
<span data-line><span>	int __user			*clear_child_tid;</span></span>
<span data-line> </span>
<span data-line><span>	/* PF_KTHREAD | PF_IO_WORKER */</span></span>
<span data-line><span>	void				*worker_private;</span></span>
<span data-line> </span>
<span data-line><span>	u64				utime;</span></span>
<span data-line><span>	u64				stime;</span></span>
<span data-line><span>#ifdef CONFIG_ARCH_HAS_SCALED_CPUTIME</span></span>
<span data-line><span>	u64				utimescaled;</span></span>
<span data-line><span>	u64				stimescaled;</span></span>
<span data-line><span>#endif</span></span>
<span data-line><span>	u64				gtime;</span></span>
<span data-line><span>	struct prev_cputime		prev_cputime;</span></span>
<span data-line><span>#ifdef CONFIG_VIRT_CPU_ACCOUNTING_GEN</span></span>
<span data-line><span>	struct vtime			vtime;</span></span>
<span data-line><span>#endif</span></span>
<span data-line> </span>
<span data-line><span>#ifdef CONFIG_NO_HZ_FULL</span></span>
<span data-line><span>	atomic_t			tick_dep_mask;</span></span>
<span data-line><span>#endif</span></span>
<span data-line><span>	/* Context switch counts: */</span></span>
<span data-line><span>	unsigned long			nvcsw;</span></span>
<span data-line><span>	unsigned long			nivcsw;</span></span>
<span data-line> </span>
<span data-line><span>	/* Monotonic time in nsecs: */</span></span>
<span data-line><span>	u64				start_time;</span></span>
<span data-line> </span>
<span data-line><span>	/* Boot based time in nsecs: */</span></span>
<span data-line><span>	u64				start_boottime;</span></span>
<span data-line> </span>
<span data-line><span>	/* MM fault and swap info: this can arguably be seen as either mm-specific or thread-specific: */</span></span>
<span data-line><span>	unsigned long			min_flt;</span></span>
<span data-line><span>	unsigned long			maj_flt;</span></span>
<span data-line> </span>
<span data-line><span>	/* Empty if CONFIG_POSIX_CPUTIMERS=n */</span></span>
<span data-line><span>	struct posix_cputimers		posix_cputimers;</span></span>
<span data-line> </span>
<span data-line><span>#ifdef CONFIG_POSIX_CPU_TIMERS_TASK_WORK</span></span>
<span data-line><span>	struct posix_cputimers_work	posix_cputimers_work;</span></span>
<span data-line><span>#endif</span></span>
<span data-line> </span>
<span data-line><span>	/* Process credentials: */</span></span>
<span data-line> </span>
<span data-line><span>	/* Tracer's credentials at attach: */</span></span>
<span data-line><span>	const struct cred __rcu		*ptracer_cred;</span></span>
<span data-line> </span>
<span data-line><span>	/* Objective and real subjective task credentials (COW): */</span></span>
<span data-line><span>	const struct cred __rcu		*real_cred;</span></span>
<span data-line> </span>
<span data-line><span>	/* Effective (overridable) subjective task credentials (COW): */</span></span>
<span data-line><span>	const struct cred __rcu		*cred;</span></span>
<span data-line> </span>
<span data-line><span>#ifdef CONFIG_KEYS</span></span>
<span data-line><span>	/* Cached requested key. */</span></span>
<span data-line><span>	struct key			*cached_requested_key;</span></span>
<span data-line><span>#endif</span></span>
<span data-line> </span>
<span data-line><span>	/*</span></span>
<span data-line><span>	 * executable name, excluding path.</span></span>
<span data-line><span>	 *</span></span>
<span data-line><span>	 * - normally initialized begin_new_exec()</span></span>
<span data-line><span>	 * - set it with set_task_comm()</span></span>
<span data-line><span>	 *   - strscpy_pad() to ensure it is always NUL-terminated and</span></span>
<span data-line><span>	 *     zero-padded</span></span>
<span data-line><span>	 *   - task_lock() to ensure the operation is atomic and the name is</span></span>
<span data-line><span>	 *     fully updated.</span></span>
<span data-line><span>	 */</span></span>
<span data-line><span>	char				comm[TASK_COMM_LEN];</span></span>
<span data-line> </span>
<span data-line><span>	struct nameidata		*nameidata;</span></span>
<span data-line> </span>
<span data-line><span>#ifdef CONFIG_SYSVIPC</span></span>
<span data-line><span>	struct sysv_sem			sysvsem;</span></span>
<span data-line><span>	struct sysv_shm			sysvshm;</span></span>
<span data-line><span>#endif</span></span>
<span data-line><span>#ifdef CONFIG_DETECT_HUNG_TASK</span></span>
<span data-line><span>	unsigned long			last_switch_count;</span></span>
<span data-line><span>	unsigned long			last_switch_time;</span></span>
<span data-line><span>#endif</span></span>
<span data-line><span>	/* Filesystem information: */</span></span>
<span data-line><span>	struct fs_struct		*fs;</span></span>
<span data-line> </span>
<span data-line><span>	/* Open file information: */</span></span>
<span data-line><span>	struct files_struct		*files;</span></span>
<span data-line> </span>
<span data-line><span>#ifdef CONFIG_IO_URING</span></span>
<span data-line><span>	struct io_uring_task		*io_uring;</span></span>
<span data-line><span>#endif</span></span>
<span data-line> </span>
<span data-line><span>	/* Namespaces: */</span></span>
<span data-line><span>	struct nsproxy			*nsproxy;</span></span>
<span data-line> </span>
<span data-line><span>	/* Signal handlers: */</span></span>
<span data-line><span>	struct signal_struct		*signal;</span></span>
<span data-line><span>	struct sighand_struct __rcu		*sighand;</span></span>
<span data-line><span>	sigset_t			blocked;</span></span>
<span data-line><span>	sigset_t			real_blocked;</span></span>
<span data-line><span>	/* Restored if set_restore_sigmask() was used: */</span></span>
<span data-line><span>	sigset_t			saved_sigmask;</span></span>
<span data-line><span>	struct sigpending		pending;</span></span>
<span data-line><span>	unsigned long			sas_ss_sp;</span></span>
<span data-line><span>	size_t				sas_ss_size;</span></span>
<span data-line><span>	unsigned int			sas_ss_flags;</span></span>
<span data-line> </span>
<span data-line><span>	struct callback_head		*task_works;</span></span>
<span data-line> </span>
<span data-line><span>#ifdef CONFIG_AUDIT</span></span>
<span data-line><span>#ifdef CONFIG_AUDITSYSCALL</span></span>
<span data-line><span>	struct audit_context		*audit_context;</span></span>
<span data-line><span>#endif</span></span>
<span data-line><span>	kuid_t				loginuid;</span></span>
<span data-line><span>	unsigned int			sessionid;</span></span>
<span data-line><span>#endif</span></span>
<span data-line><span>	struct seccomp			seccomp;</span></span>
<span data-line><span>	struct syscall_user_dispatch	syscall_dispatch;</span></span>
<span data-line> </span>
<span data-line><span>	/* Thread group tracking: */</span></span>
<span data-line><span>	u64				parent_exec_id;</span></span>
<span data-line><span>	u64				self_exec_id;</span></span>
<span data-line> </span>
<span data-line><span>	/* Protection against (de-)allocation: mm, files, fs, tty, keyrings, mems_allowed, mempolicy: */</span></span>
<span data-line><span>	spinlock_t			alloc_lock;</span></span>
<span data-line> </span>
<span data-line><span>	/* Protection of the PI data structures: */</span></span>
<span data-line><span>	raw_spinlock_t			pi_lock;</span></span>
<span data-line> </span>
<span data-line><span>	struct wake_q_node		wake_q;</span></span>
<span data-line> </span>
<span data-line><span>#ifdef CONFIG_RT_MUTEXES</span></span>
<span data-line><span>	/* PI waiters blocked on a rt_mutex held by this task: */</span></span>
<span data-line><span>	struct rb_root_cached		pi_waiters;</span></span>
<span data-line><span>	/* Updated under owner's pi_lock and rq lock */</span></span>
<span data-line><span>	struct task_struct		*pi_top_task;</span></span>
<span data-line><span>	/* Deadlock detection and priority inheritance handling: */</span></span>
<span data-line><span>	struct rt_mutex_waiter		*pi_blocked_on;</span></span>
<span data-line><span>#endif</span></span>
<span data-line> </span>
<span data-line><span>	struct mutex			*blocked_on;	/* lock we're blocked on */</span></span>
<span data-line> </span>
<span data-line><span>#ifdef CONFIG_DETECT_HUNG_TASK_BLOCKER</span></span>
<span data-line><span>	/*</span></span>
<span data-line><span>	 * Encoded lock address causing task block (lower 2 bits = type from</span></span>
<span data-line><span>	 * &lt;linux/hung_task.h>). Accessed via hung_task_*() helpers.</span></span>
<span data-line><span>	 */</span></span>
<span data-line><span>	unsigned long			blocker;</span></span>
<span data-line><span>#endif</span></span>
<span data-line> </span>
<span data-line><span>#ifdef CONFIG_DEBUG_ATOMIC_SLEEP</span></span>
<span data-line><span>	int				non_block_count;</span></span>
<span data-line><span>#endif</span></span>
<span data-line> </span>
<span data-line><span>#ifdef CONFIG_TRACE_IRQFLAGS</span></span>
<span data-line><span>	struct irqtrace_events		irqtrace;</span></span>
<span data-line><span>	unsigned int			hardirq_threaded;</span></span>
<span data-line><span>	u64				hardirq_chain_key;</span></span>
<span data-line><span>	int				softirqs_enabled;</span></span>
<span data-line><span>	int				softirq_context;</span></span>
<span data-line><span>	int				irq_config;</span></span>
<span data-line><span>#endif</span></span>
<span data-line><span>#ifdef CONFIG_PREEMPT_RT</span></span>
<span data-line><span>	int				softirq_disable_cnt;</span></span>
<span data-line><span>#endif</span></span>
<span data-line> </span>
<span data-line><span>#ifdef CONFIG_LOCKDEP</span></span>
<span data-line><span>#define MAX_LOCK_DEPTH			48UL</span></span>
<span data-line><span>	u64				curr_chain_key;</span></span>
<span data-line><span>	int				lockdep_depth;</span></span>
<span data-line><span>	unsigned int			lockdep_recursion;</span></span>
<span data-line><span>	struct held_lock		held_locks[MAX_LOCK_DEPTH];</span></span>
<span data-line><span>#endif</span></span>
<span data-line> </span>
<span data-line><span>#if defined(CONFIG_UBSAN) &amp;&amp; !defined(CONFIG_UBSAN_TRAP)</span></span>
<span data-line><span>	unsigned int			in_ubsan;</span></span>
<span data-line><span>#endif</span></span>
<span data-line> </span>
<span data-line><span>	/* Journalling filesystem info: */</span></span>
<span data-line><span>	void				*journal_info;</span></span>
<span data-line> </span>
<span data-line><span>	/* Stacked block device info: */</span></span>
<span data-line><span>	struct bio_list			*bio_list;</span></span>
<span data-line> </span>
<span data-line><span>	/* Stack plugging: */</span></span>
<span data-line><span>	struct blk_plug			*plug;</span></span>
<span data-line> </span>
<span data-line><span>	/* VM state: */</span></span>
<span data-line><span>	struct reclaim_state		*reclaim_state;</span></span>
<span data-line> </span>
<span data-line><span>	struct io_context		*io_context;</span></span>
<span data-line> </span>
<span data-line><span>#ifdef CONFIG_COMPACTION</span></span>
<span data-line><span>	struct capture_control		*capture_control;</span></span>
<span data-line><span>#endif</span></span>
<span data-line><span>	/* Ptrace state: */</span></span>
<span data-line><span>	unsigned long			ptrace_message;</span></span>
<span data-line><span>	kernel_siginfo_t		*last_siginfo;</span></span>
<span data-line> </span>
<span data-line><span>	struct task_io_accounting	ioac;</span></span>
<span data-line><span>#ifdef CONFIG_PSI</span></span>
<span data-line><span>	/* Pressure stall state */</span></span>
<span data-line><span>	unsigned int			psi_flags;</span></span>
<span data-line><span>#endif</span></span>
<span data-line><span>#ifdef CONFIG_TASK_XACCT</span></span>
<span data-line><span>	/* Accumulated RSS usage: */</span></span>
<span data-line><span>	u64				acct_rss_mem1;</span></span>
<span data-line><span>	/* Accumulated virtual memory usage: */</span></span>
<span data-line><span>	u64				acct_vm_mem1;</span></span>
<span data-line><span>	/* stime + utime since last update: */</span></span>
<span data-line><span>	u64				acct_timexpd;</span></span>
<span data-line><span>#endif</span></span>
<span data-line><span>#ifdef CONFIG_CPUSETS</span></span>
<span data-line><span>	/* Protected by ->alloc_lock: */</span></span>
<span data-line><span>	nodemask_t			mems_allowed;</span></span>
<span data-line><span>	/* Sequence number to catch updates: */</span></span>
<span data-line><span>	seqcount_spinlock_t		mems_allowed_seq;</span></span>
<span data-line><span>	int				cpuset_mem_spread_rotor;</span></span>
<span data-line><span>#endif</span></span>
<span data-line><span>#ifdef CONFIG_CGROUPS</span></span>
<span data-line><span>	/* Control Group info protected by css_set_lock: */</span></span>
<span data-line><span>	struct css_set __rcu		*cgroups;</span></span>
<span data-line><span>	/* cg_list protected by css_set_lock and tsk->alloc_lock: */</span></span>
<span data-line><span>	struct list_head		cg_list;</span></span>
<span data-line><span>#endif</span></span>
<span data-line><span>#ifdef CONFIG_X86_CPU_RESCTRL</span></span>
<span data-line><span>	u32				closid;</span></span>
<span data-line><span>	u32				rmid;</span></span>
<span data-line><span>#endif</span></span>
<span data-line><span>#ifdef CONFIG_FUTEX</span></span>
<span data-line><span>	struct robust_list_head __user	*robust_list;</span></span>
<span data-line><span>#ifdef CONFIG_COMPAT</span></span>
<span data-line><span>	struct compat_robust_list_head __user *compat_robust_list;</span></span>
<span data-line><span>#endif</span></span>
<span data-line><span>	struct list_head		pi_state_list;</span></span>
<span data-line><span>	struct futex_pi_state		*pi_state_cache;</span></span>
<span data-line><span>	struct mutex			futex_exit_mutex;</span></span>
<span data-line><span>	unsigned int			futex_state;</span></span>
<span data-line><span>#endif</span></span>
<span data-line><span>#ifdef CONFIG_PERF_EVENTS</span></span>
<span data-line><span>	u8				perf_recursion[PERF_NR_CONTEXTS];</span></span>
<span data-line><span>	struct perf_event_context	*perf_event_ctxp;</span></span>
<span data-line><span>	struct mutex			perf_event_mutex;</span></span>
<span data-line><span>	struct list_head		perf_event_list;</span></span>
<span data-line><span>	struct perf_ctx_data __rcu	*perf_ctx_data;</span></span>
<span data-line><span>#endif</span></span>
<span data-line><span>#ifdef CONFIG_DEBUG_PREEMPT</span></span>
<span data-line><span>	unsigned long			preempt_disable_ip;</span></span>
<span data-line><span>#endif</span></span>
<span data-line><span>#ifdef CONFIG_NUMA</span></span>
<span data-line><span>	/* Protected by alloc_lock: */</span></span>
<span data-line><span>	struct mempolicy		*mempolicy;</span></span>
<span data-line><span>	short				il_prev;</span></span>
<span data-line><span>	u8				il_weight;</span></span>
<span data-line><span>	short				pref_node_fork;</span></span>
<span data-line><span>#endif</span></span>
<span data-line><span>#ifdef CONFIG_NUMA_BALANCING</span></span>
<span data-line><span>	int				numa_scan_seq;</span></span>
<span data-line><span>	unsigned int			numa_scan_period;</span></span>
<span data-line><span>	unsigned int			numa_scan_period_max;</span></span>
<span data-line><span>	int				numa_preferred_nid;</span></span>
<span data-line><span>	unsigned long			numa_migrate_retry;</span></span>
<span data-line><span>	/* Migration stamp: */</span></span>
<span data-line><span>	u64				node_stamp;</span></span>
<span data-line><span>	u64				last_task_numa_placement;</span></span>
<span data-line><span>	u64				last_sum_exec_runtime;</span></span>
<span data-line><span>	struct callback_head		numa_work;</span></span>
<span data-line> </span>
<span data-line><span>	/*</span></span>
<span data-line><span>	 * This pointer is only modified for current in syscall and</span></span>
<span data-line><span>	 * pagefault context (and for tasks being destroyed), so it can be read</span></span>
<span data-line><span>	 * from any of the following contexts:</span></span>
<span data-line><span>	 *  - RCU read-side critical section</span></span>
<span data-line><span>	 *  - current->numa_group from everywhere</span></span>
<span data-line><span>	 *  - task's runqueue locked, task not running</span></span>
<span data-line><span>	 */</span></span>
<span data-line><span>	struct numa_group __rcu		*numa_group;</span></span>
<span data-line> </span>
<span data-line><span>	/*</span></span>
<span data-line><span>	 * numa_faults is an array split into four regions:</span></span>
<span data-line><span>	 * faults_memory, faults_cpu, faults_memory_buffer, faults_cpu_buffer</span></span>
<span data-line><span>	 * in this precise order.</span></span>
<span data-line><span>	 *</span></span>
<span data-line><span>	 * faults_memory: Exponential decaying average of faults on a per-node</span></span>
<span data-line><span>	 * basis. Scheduling placement decisions are made based on these</span></span>
<span data-line><span>	 * counts. The values remain static for the duration of a PTE scan.</span></span>
<span data-line><span>	 * faults_cpu: Track the nodes the process was running on when a NUMA</span></span>
<span data-line><span>	 * hinting fault was incurred.</span></span>
<span data-line><span>	 * faults_memory_buffer and faults_cpu_buffer: Record faults per node</span></span>
<span data-line><span>	 * during the current scan window. When the scan completes, the counts</span></span>
<span data-line><span>	 * in faults_memory and faults_cpu decay and these values are copied.</span></span>
<span data-line><span>	 */</span></span>
<span data-line><span>	unsigned long			*numa_faults;</span></span>
<span data-line><span>	unsigned long			total_numa_faults;</span></span>
<span data-line> </span>
<span data-line><span>	/*</span></span>
<span data-line><span>	 * numa_faults_locality tracks if faults recorded during the last</span></span>
<span data-line><span>	 * scan window were remote/local or failed to migrate. The task scan</span></span>
<span data-line><span>	 * period is adapted based on the locality of the faults with different</span></span>
<span data-line><span>	 * weights depending on whether they were shared or private faults</span></span>
<span data-line><span>	 */</span></span>
<span data-line><span>	unsigned long			numa_faults_locality[3];</span></span>
<span data-line> </span>
<span data-line><span>	unsigned long			numa_pages_migrated;</span></span>
<span data-line><span>#endif /* CONFIG_NUMA_BALANCING */</span></span>
<span data-line> </span>
<span data-line><span>#ifdef CONFIG_RSEQ</span></span>
<span data-line><span>	struct rseq __user *rseq;</span></span>
<span data-line><span>	u32 rseq_len;</span></span>
<span data-line><span>	u32 rseq_sig;</span></span>
<span data-line><span>	/*</span></span>
<span data-line><span>	 * RmW on rseq_event_mask must be performed atomically</span></span>
<span data-line><span>	 * with respect to preemption.</span></span>
<span data-line><span>	 */</span></span>
<span data-line><span>	unsigned long rseq_event_mask;</span></span>
<span data-line><span>#ifdef CONFIG_DEBUG_RSEQ</span></span>
<span data-line><span>	/*</span></span>
<span data-line><span>	 * This is a place holder to save a copy of the rseq fields for</span></span>
<span data-line><span>	 * validation of read-only fields. The struct rseq has a</span></span>
<span data-line><span>	 * variable-length array at the end, so it cannot be used</span></span>
<span data-line><span>	 * directly. Reserve a size large enough for the known fields.</span></span>
<span data-line><span>	 */</span></span>
<span data-line><span>	char				rseq_fields[sizeof(struct rseq)];</span></span>
<span data-line><span>#endif</span></span>
<span data-line><span>#endif</span></span>
<span data-line> </span>
<span data-line><span>#ifdef CONFIG_SCHED_MM_CID</span></span>
<span data-line><span>	int				mm_cid;		/* Current cid in mm */</span></span>
<span data-line><span>	int				last_mm_cid;	/* Most recent cid in mm */</span></span>
<span data-line><span>	int				migrate_from_cpu;</span></span>
<span data-line><span>	int				mm_cid_active;	/* Whether cid bitmap is active */</span></span>
<span data-line><span>	struct callback_head		cid_work;</span></span>
<span data-line><span>#endif</span></span>
<span data-line> </span>
<span data-line><span>	struct tlbflush_unmap_batch	tlb_ubc;</span></span>
<span data-line> </span>
<span data-line><span>	/* Cache last used pipe for splice(): */</span></span>
<span data-line><span>	struct pipe_inode_info		*splice_pipe;</span></span>
<span data-line> </span>
<span data-line><span>	struct page_frag		task_frag;</span></span>
<span data-line> </span>
<span data-line><span>#ifdef CONFIG_TASK_DELAY_ACCT</span></span>
<span data-line><span>	struct task_delay_info		*delays;</span></span>
<span data-line><span>#endif</span></span>
<span data-line> </span>
<span data-line><span>#ifdef CONFIG_FAULT_INJECTION</span></span>
<span data-line><span>	int				make_it_fail;</span></span>
<span data-line><span>	unsigned int			fail_nth;</span></span>
<span data-line><span>#endif</span></span>
<span data-line><span>	/*</span></span>
<span data-line><span>	 * When (nr_dirtied >= nr_dirtied_pause), it's time to call</span></span>
<span data-line><span>	 * balance_dirty_pages() for a dirty throttling pause:</span></span>
<span data-line><span>	 */</span></span>
<span data-line><span>	int				nr_dirtied;</span></span>
<span data-line><span>	int				nr_dirtied_pause;</span></span>
<span data-line><span>	/* Start of a write-and-pause period: */</span></span>
<span data-line><span>	unsigned long			dirty_paused_when;</span></span>
<span data-line> </span>
<span data-line><span>#ifdef CONFIG_LATENCYTOP</span></span>
<span data-line><span>	int				latency_record_count;</span></span>
<span data-line><span>	struct latency_record		latency_record[LT_SAVECOUNT];</span></span>
<span data-line><span>#endif</span></span>
<span data-line><span>	/*</span></span>
<span data-line><span>	 * Time slack values; these are used to round up poll() and</span></span>
<span data-line><span>	 * select() etc timeout values. These are in nanoseconds.</span></span>
<span data-line><span>	 */</span></span>
<span data-line><span>	u64				timer_slack_ns;</span></span>
<span data-line><span>	u64				default_timer_slack_ns;</span></span>
<span data-line> </span>
<span data-line><span>#if defined(CONFIG_KASAN_GENERIC) || defined(CONFIG_KASAN_SW_TAGS)</span></span>
<span data-line><span>	unsigned int			kasan_depth;</span></span>
<span data-line><span>#endif</span></span>
<span data-line> </span>
<span data-line><span>#ifdef CONFIG_KCSAN</span></span>
<span data-line><span>	struct kcsan_ctx		kcsan_ctx;</span></span>
<span data-line><span>#ifdef CONFIG_TRACE_IRQFLAGS</span></span>
<span data-line><span>	struct irqtrace_events		kcsan_save_irqtrace;</span></span>
<span data-line><span>#endif</span></span>
<span data-line><span>#ifdef CONFIG_KCSAN_WEAK_MEMORY</span></span>
<span data-line><span>	int				kcsan_stack_depth;</span></span>
<span data-line><span>#endif</span></span>
<span data-line><span>#endif</span></span>
<span data-line> </span>
<span data-line><span>#ifdef CONFIG_KMSAN</span></span>
<span data-line><span>	struct kmsan_ctx		kmsan_ctx;</span></span>
<span data-line><span>#endif</span></span>
<span data-line> </span>
<span data-line><span>#if IS_ENABLED(CONFIG_KUNIT)</span></span>
<span data-line><span>	struct kunit			*kunit_test;</span></span>
<span data-line><span>#endif</span></span>
<span data-line> </span>
<span data-line><span>#ifdef CONFIG_FUNCTION_GRAPH_TRACER</span></span>
<span data-line><span>	/* Index of current stored address in ret_stack: */</span></span>
<span data-line><span>	int				curr_ret_stack;</span></span>
<span data-line><span>	int				curr_ret_depth;</span></span>
<span data-line> </span>
<span data-line><span>	/* Stack of return addresses for return function tracing: */</span></span>
<span data-line><span>	unsigned long			*ret_stack;</span></span>
<span data-line> </span>
<span data-line><span>	/* Timestamp for last schedule: */</span></span>
<span data-line><span>	unsigned long long		ftrace_timestamp;</span></span>
<span data-line><span>	unsigned long long		ftrace_sleeptime;</span></span>
<span data-line> </span>
<span data-line><span>	/*</span></span>
<span data-line><span>	 * Number of functions that haven't been traced</span></span>
<span data-line><span>	 * because of depth overrun:</span></span>
<span data-line><span>	 */</span></span>
<span data-line><span>	atomic_t			trace_overrun;</span></span>
<span data-line> </span>
<span data-line><span>	/* Pause tracing: */</span></span>
<span data-line><span>	atomic_t			tracing_graph_pause;</span></span>
<span data-line><span>#endif</span></span>
<span data-line> </span>
<span data-line><span>#ifdef CONFIG_TRACING</span></span>
<span data-line><span>	/* Bitmask and counter of trace recursion: */</span></span>
<span data-line><span>	unsigned long			trace_recursion;</span></span>
<span data-line><span>#endif /* CONFIG_TRACING */</span></span>
<span data-line> </span>
<span data-line><span>#ifdef CONFIG_KCOV</span></span>
<span data-line><span>	/* See kernel/kcov.c for more details. */</span></span>
<span data-line> </span>
<span data-line><span>	/* Coverage collection mode enabled for this task (0 if disabled): */</span></span>
<span data-line><span>	unsigned int			kcov_mode;</span></span>
<span data-line> </span>
<span data-line><span>	/* Size of the kcov_area: */</span></span>
<span data-line><span>	unsigned int			kcov_size;</span></span>
<span data-line> </span>
<span data-line><span>	/* Buffer for coverage collection: */</span></span>
<span data-line><span>	void				*kcov_area;</span></span>
<span data-line> </span>
<span data-line><span>	/* KCOV descriptor wired with this task or NULL: */</span></span>
<span data-line><span>	struct kcov			*kcov;</span></span>
<span data-line> </span>
<span data-line><span>	/* KCOV common handle for remote coverage collection: */</span></span>
<span data-line><span>	u64				kcov_handle;</span></span>
<span data-line> </span>
<span data-line><span>	/* KCOV sequence number: */</span></span>
<span data-line><span>	int				kcov_sequence;</span></span>
<span data-line> </span>
<span data-line><span>	/* Collect coverage from softirq context: */</span></span>
<span data-line><span>	unsigned int			kcov_softirq;</span></span>
<span data-line><span>#endif</span></span>
<span data-line> </span>
<span data-line><span>#ifdef CONFIG_MEMCG_V1</span></span>
<span data-line><span>	struct mem_cgroup		*memcg_in_oom;</span></span>
<span data-line><span>#endif</span></span>
<span data-line> </span>
<span data-line><span>#ifdef CONFIG_MEMCG</span></span>
<span data-line><span>	/* Number of pages to reclaim on returning to userland: */</span></span>
<span data-line><span>	unsigned int			memcg_nr_pages_over_high;</span></span>
<span data-line> </span>
<span data-line><span>	/* Used by memcontrol for targeted memcg charge: */</span></span>
<span data-line><span>	struct mem_cgroup		*active_memcg;</span></span>
<span data-line> </span>
<span data-line><span>	/* Cache for current->cgroups->memcg->objcg lookups: */</span></span>
<span data-line><span>	struct obj_cgroup		*objcg;</span></span>
<span data-line><span>#endif</span></span>
<span data-line> </span>
<span data-line><span>#ifdef CONFIG_BLK_CGROUP</span></span>
<span data-line><span>	struct gendisk			*throttle_disk;</span></span>
<span data-line><span>#endif</span></span>
<span data-line> </span>
<span data-line><span>#ifdef CONFIG_UPROBES</span></span>
<span data-line><span>	struct uprobe_task		*utask;</span></span>
<span data-line><span>#endif</span></span>
<span data-line><span>#if defined(CONFIG_BCACHE) || defined(CONFIG_BCACHE_MODULE)</span></span>
<span data-line><span>	unsigned int			sequential_io;</span></span>
<span data-line><span>	unsigned int			sequential_io_avg;</span></span>
<span data-line><span>#endif</span></span>
<span data-line><span>	struct kmap_ctrl		kmap_ctrl;</span></span>
<span data-line><span>#ifdef CONFIG_DEBUG_ATOMIC_SLEEP</span></span>
<span data-line><span>	unsigned long			task_state_change;</span></span>
<span data-line><span>#ifdef CONFIG_PREEMPT_RT</span></span>
<span data-line><span>	unsigned long			saved_state_change;</span></span>
<span data-line><span>#endif</span></span>
<span data-line><span>#endif</span></span>
<span data-line><span>	struct rcu_head			rcu;</span></span>
<span data-line><span>	refcount_t			rcu_users;</span></span>
<span data-line><span>	int				pagefault_disabled;</span></span>
<span data-line><span>#ifdef CONFIG_MMU</span></span>
<span data-line><span>	struct task_struct		*oom_reaper_list;</span></span>
<span data-line><span>	struct timer_list		oom_reaper_timer;</span></span>
<span data-line><span>#endif</span></span>
<span data-line><span>#ifdef CONFIG_VMAP_STACK</span></span>
<span data-line><span>	struct vm_struct		*stack_vm_area;</span></span>
<span data-line><span>#endif</span></span>
<span data-line><span>#ifdef CONFIG_THREAD_INFO_IN_TASK</span></span>
<span data-line><span>	/* A live task holds one reference: */</span></span>
<span data-line><span>	refcount_t			stack_refcount;</span></span>
<span data-line><span>#endif</span></span>
<span data-line><span>#ifdef CONFIG_LIVEPATCH</span></span>
<span data-line><span>	int patch_state;</span></span>
<span data-line><span>#endif</span></span>
<span data-line><span>#ifdef CONFIG_SECURITY</span></span>
<span data-line><span>	/* Used by LSM modules for access restriction: */</span></span>
<span data-line><span>	void				*security;</span></span>
<span data-line><span>#endif</span></span>
<span data-line><span>#ifdef CONFIG_BPF_SYSCALL</span></span>
<span data-line><span>	/* Used by BPF task local storage */</span></span>
<span data-line><span>	struct bpf_local_storage __rcu	*bpf_storage;</span></span>
<span data-line><span>	/* Used for BPF run context */</span></span>
<span data-line><span>	struct bpf_run_ctx		*bpf_ctx;</span></span>
<span data-line><span>#endif</span></span>
<span data-line><span>	/* Used by BPF for per-TASK xdp storage */</span></span>
<span data-line><span>	struct bpf_net_context		*bpf_net_context;</span></span>
<span data-line> </span>
<span data-line><span>#ifdef CONFIG_KSTACK_ERASE</span></span>
<span data-line><span>	unsigned long			lowest_stack;</span></span>
<span data-line><span>#endif</span></span>
<span data-line><span>#ifdef CONFIG_KSTACK_ERASE_METRICS</span></span>
<span data-line><span>	unsigned long			prev_lowest_stack;</span></span>
<span data-line><span>#endif</span></span>
<span data-line> </span>
<span data-line><span>#ifdef CONFIG_X86_MCE</span></span>
<span data-line><span>	void __user			*mce_vaddr;</span></span>
<span data-line><span>	__u64				mce_kflags;</span></span>
<span data-line><span>	u64				mce_addr;</span></span>
<span data-line><span>	__u64				mce_ripv : 1,</span></span>
<span data-line><span>					mce_whole_page : 1,</span></span>
<span data-line><span>					__mce_reserved : 62;</span></span>
<span data-line><span>	struct callback_head		mce_kill_me;</span></span>
<span data-line><span>	int				mce_count;</span></span>
<span data-line><span>#endif</span></span>
<span data-line> </span>
<span data-line><span>#ifdef CONFIG_KRETPROBES</span></span>
<span data-line><span>	struct llist_head               kretprobe_instances;</span></span>
<span data-line><span>#endif</span></span>
<span data-line><span>#ifdef CONFIG_RETHOOK</span></span>
<span data-line><span>	struct llist_head               rethooks;</span></span>
<span data-line><span>#endif</span></span>
<span data-line> </span>
<span data-line><span>#ifdef CONFIG_ARCH_HAS_PARANOID_L1D_FLUSH</span></span>
<span data-line><span>	/*</span></span>
<span data-line><span>	 * If L1D flush is supported on mm context switch</span></span>
<span data-line><span>	 * then we use this callback head to queue kill work</span></span>
<span data-line><span>	 * to kill tasks that are not running on SMT disabled</span></span>
<span data-line><span>	 * cores</span></span>
<span data-line><span>	 */</span></span>
<span data-line><span>	struct callback_head		l1d_flush_kill;</span></span>
<span data-line><span>#endif</span></span>
<span data-line> </span>
<span data-line><span>#ifdef CONFIG_RV</span></span>
<span data-line><span>	/*</span></span>
<span data-line><span>	 * Per-task RV monitor, fixed in CONFIG_RV_PER_TASK_MONITORS.</span></span>
<span data-line><span>	 * If memory becomes a concern, we can think about a dynamic method.</span></span>
<span data-line><span>	 */</span></span>
<span data-line><span>	union rv_task_monitor		rv[CONFIG_RV_PER_TASK_MONITORS];</span></span>
<span data-line><span>#endif</span></span>
<span data-line> </span>
<span data-line><span>#ifdef CONFIG_USER_EVENTS</span></span>
<span data-line><span>	struct user_event_mm		*user_event_mm;</span></span>
<span data-line><span>#endif</span></span>
<span data-line> </span>
<span data-line><span>#ifdef CONFIG_UNWIND_USER</span></span>
<span data-line><span>	struct unwind_task_info		unwind_info;</span></span>
<span data-line><span>#endif</span></span>
<span data-line> </span>
<span data-line><span>	/* CPU-specific state of this task: */</span></span>
<span data-line><span>	struct thread_struct		thread;</span></span>
<span data-line> </span>
<span data-line><span>	/*</span></span>
<span data-line><span>	 * New fields for task_struct should be added above here, so that</span></span>
<span data-line><span>	 * they are included in the randomized portion of task_struct.</span></span>
<span data-line><span>	 */</span></span>
<span data-line><span>	randomized_struct_fields_end</span></span>
<span data-line><span>} __attribute__ ((aligned (64)));</span></span></code></pre></figure>
</div>
</blockquote>
<figure data-rehype-pretty-code-figure><figcaption data-rehype-pretty-code-title data-language="C" data-theme="github-light github-dark">testing</figcaption><pre tabindex="0" data-language="C" data-theme="github-light github-dark"><code data-language="C" data-theme="github-light github-dark" style="display:grid;"><span data-line><span>int main(){</span></span>
<span data-line><span>	pritnf(&quot;Hello, world!&quot;);</span></span>
<span data-line><span>}</span></span></code></pre></figure>
<p>Going into this behemoth of code isn’t something that we should do, once the time comes we will go into that i guess</p></article><hr/><div class="page-footer"></div></div><div class="right sidebar"><div class="graph"><h3>Graph View</h3><div class="graph-outer"><div class="graph-container" data-cfg="{&quot;drag&quot;:true,&quot;zoom&quot;:true,&quot;depth&quot;:1,&quot;scale&quot;:1.1,&quot;repelForce&quot;:0.5,&quot;centerForce&quot;:0.3,&quot;linkDistance&quot;:30,&quot;fontSize&quot;:0.6,&quot;opacityScale&quot;:1,&quot;showTags&quot;:true,&quot;removeTags&quot;:[],&quot;focusOnHover&quot;:false,&quot;enableRadial&quot;:false}"></div><button class="global-graph-icon" aria-label="Global Graph"><svg version="1.1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" x="0px" y="0px" viewBox="0 0 55 55" fill="currentColor" xml:space="preserve"><path d="M49,0c-3.309,0-6,2.691-6,6c0,1.035,0.263,2.009,0.726,2.86l-9.829,9.829C32.542,17.634,30.846,17,29,17
                s-3.542,0.634-4.898,1.688l-7.669-7.669C16.785,10.424,17,9.74,17,9c0-2.206-1.794-4-4-4S9,6.794,9,9s1.794,4,4,4
                c0.74,0,1.424-0.215,2.019-0.567l7.669,7.669C21.634,21.458,21,23.154,21,25s0.634,3.542,1.688,4.897L10.024,42.562
                C8.958,41.595,7.549,41,6,41c-3.309,0-6,2.691-6,6s2.691,6,6,6s6-2.691,6-6c0-1.035-0.263-2.009-0.726-2.86l12.829-12.829
                c1.106,0.86,2.44,1.436,3.898,1.619v10.16c-2.833,0.478-5,2.942-5,5.91c0,3.309,2.691,6,6,6s6-2.691,6-6c0-2.967-2.167-5.431-5-5.91
                v-10.16c1.458-0.183,2.792-0.759,3.898-1.619l7.669,7.669C41.215,39.576,41,40.26,41,41c0,2.206,1.794,4,4,4s4-1.794,4-4
                s-1.794-4-4-4c-0.74,0-1.424,0.215-2.019,0.567l-7.669-7.669C36.366,28.542,37,26.846,37,25s-0.634-3.542-1.688-4.897l9.665-9.665
                C46.042,11.405,47.451,12,49,12c3.309,0,6-2.691,6-6S52.309,0,49,0z M11,9c0-1.103,0.897-2,2-2s2,0.897,2,2s-0.897,2-2,2
                S11,10.103,11,9z M6,51c-2.206,0-4-1.794-4-4s1.794-4,4-4s4,1.794,4,4S8.206,51,6,51z M33,49c0,2.206-1.794,4-4,4s-4-1.794-4-4
                s1.794-4,4-4S33,46.794,33,49z M29,31c-3.309,0-6-2.691-6-6s2.691-6,6-6s6,2.691,6,6S32.309,31,29,31z M47,41c0,1.103-0.897,2-2,2
                s-2-0.897-2-2s0.897-2,2-2S47,39.897,47,41z M49,10c-2.206,0-4-1.794-4-4s1.794-4,4-4s4,1.794,4,4S51.206,10,49,10z"></path></svg></button></div><div class="global-graph-outer"><div class="global-graph-container" data-cfg="{&quot;drag&quot;:true,&quot;zoom&quot;:true,&quot;depth&quot;:-1,&quot;scale&quot;:0.9,&quot;repelForce&quot;:0.5,&quot;centerForce&quot;:0.2,&quot;linkDistance&quot;:30,&quot;fontSize&quot;:0.6,&quot;opacityScale&quot;:1,&quot;showTags&quot;:true,&quot;removeTags&quot;:[],&quot;focusOnHover&quot;:true,&quot;enableRadial&quot;:true}"></div></div></div><div class="toc desktop-only"><button type="button" class="toc-header" aria-controls="toc-0" aria-expanded="true"><h3>Table of Contents</h3><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="fold"><polyline points="6 9 12 15 18 9"></polyline></svg></button><ul id="list-1" class="toc-content overflow"><li class="depth-0"><a href="#process-definition" data-for="process-definition">Process Definition</a></li><li class="depth-2"><a href="#notespanrarrspan-another-name-for-a-process-is-a-task-the-linux-kernel-internally-refers-to-processes-as-tasks" data-for="notespanrarrspan-another-name-for-a-process-is-a-task-the-linux-kernel-internally-refers-to-processes-as-tasks">Note&lt;span>&amp;rarr;&lt;/span> Another name for a process is a task. The Linux kernel internally refers to processes as tasks.</a></li><li class="depth-0"><a href="#fork-workings" data-for="fork-workings">fork() workings</a></li><li class="depth-0"><a href="#process-descriptor-and-task-structure" data-for="process-descriptor-and-task-structure">Process Descriptor and Task Structure</a></li><li class="overflow-end"></li></ul></div><div class="backlinks"><h3>Backlinks</h3><ul id="list-2" class="overflow"><li><a href="../Kotia/Kotia's-Home" class="internal">Kotia - Fish in the Sea</a></li><li class="overflow-end"></li></ul></div></div><footer class><p>Created with <a href="https://quartz.jzhao.xyz/">Quartz v4.5.2</a> © 2025</p><ul><li><a href="https://github.com/jackyzha0/quartz">GitHub</a></li><li><a href="https://discord.gg/cRFFHYye7t">Discord Community</a></li></ul></footer></div></div></body><script type="application/javascript">function n(){let t=this.parentElement;t.classList.toggle("is-collapsed");let e=t.getElementsByClassName("callout-content")[0];if(!e)return;let l=t.classList.contains("is-collapsed");e.style.gridTemplateRows=l?"0fr":"1fr"}function c(){let t=document.getElementsByClassName("callout is-collapsible");for(let e of t){let l=e.getElementsByClassName("callout-title")[0],s=e.getElementsByClassName("callout-content")[0];if(!l||!s)continue;l.addEventListener("click",n),window.addCleanup(()=>l.removeEventListener("click",n));let o=e.classList.contains("is-collapsed");s.style.gridTemplateRows=o?"0fr":"1fr"}}document.addEventListener("nav",c);
</script><script type="module">function f(i,e){if(!i)return;function r(o){o.target===this&&(o.preventDefault(),o.stopPropagation(),e())}function t(o){o.key.startsWith("Esc")&&(o.preventDefault(),e())}i?.addEventListener("click",r),window.addCleanup(()=>i?.removeEventListener("click",r)),document.addEventListener("keydown",t),window.addCleanup(()=>document.removeEventListener("keydown",t))}function y(i){for(;i.firstChild;)i.removeChild(i.firstChild)}var h=class{constructor(e,r){this.container=e;this.content=r;this.setupEventListeners(),this.setupNavigationControls(),this.resetTransform()}isDragging=!1;startPan={x:0,y:0};currentPan={x:0,y:0};scale=1;MIN_SCALE=.5;MAX_SCALE=3;cleanups=[];setupEventListeners(){let e=this.onMouseDown.bind(this),r=this.onMouseMove.bind(this),t=this.onMouseUp.bind(this),o=this.resetTransform.bind(this);this.container.addEventListener("mousedown",e),document.addEventListener("mousemove",r),document.addEventListener("mouseup",t),window.addEventListener("resize",o),this.cleanups.push(()=>this.container.removeEventListener("mousedown",e),()=>document.removeEventListener("mousemove",r),()=>document.removeEventListener("mouseup",t),()=>window.removeEventListener("resize",o))}cleanup(){for(let e of this.cleanups)e()}setupNavigationControls(){let e=document.createElement("div");e.className="mermaid-controls";let r=this.createButton("+",()=>this.zoom(.1)),t=this.createButton("-",()=>this.zoom(-.1)),o=this.createButton("Reset",()=>this.resetTransform());e.appendChild(t),e.appendChild(o),e.appendChild(r),this.container.appendChild(e)}createButton(e,r){let t=document.createElement("button");return t.textContent=e,t.className="mermaid-control-button",t.addEventListener("click",r),window.addCleanup(()=>t.removeEventListener("click",r)),t}onMouseDown(e){e.button===0&&(this.isDragging=!0,this.startPan={x:e.clientX-this.currentPan.x,y:e.clientY-this.currentPan.y},this.container.style.cursor="grabbing")}onMouseMove(e){this.isDragging&&(e.preventDefault(),this.currentPan={x:e.clientX-this.startPan.x,y:e.clientY-this.startPan.y},this.updateTransform())}onMouseUp(){this.isDragging=!1,this.container.style.cursor="grab"}zoom(e){let r=Math.min(Math.max(this.scale+e,this.MIN_SCALE),this.MAX_SCALE),t=this.content.getBoundingClientRect(),o=t.width/2,n=t.height/2,c=r-this.scale;this.currentPan.x-=o*c,this.currentPan.y-=n*c,this.scale=r,this.updateTransform()}updateTransform(){this.content.style.transform=`translate(${this.currentPan.x}px, ${this.currentPan.y}px) scale(${this.scale})`}resetTransform(){this.scale=1;let e=this.content.querySelector("svg");this.currentPan={x:e.getBoundingClientRect().width/2,y:e.getBoundingClientRect().height/2},this.updateTransform()}},C=["--secondary","--tertiary","--gray","--light","--lightgray","--highlight","--dark","--darkgray","--codeFont"],E;document.addEventListener("nav",async()=>{let e=document.querySelector(".center").querySelectorAll("code.mermaid");if(e.length===0)return;E||=await import("https://cdnjs.cloudflare.com/ajax/libs/mermaid/11.4.0/mermaid.esm.min.mjs");let r=E.default,t=new WeakMap;for(let n of e)t.set(n,n.innerText);async function o(){for(let s of e){s.removeAttribute("data-processed");let a=t.get(s);a&&(s.innerHTML=a)}let n=C.reduce((s,a)=>(s[a]=window.getComputedStyle(document.documentElement).getPropertyValue(a),s),{}),c=document.documentElement.getAttribute("saved-theme")==="dark";r.initialize({startOnLoad:!1,securityLevel:"loose",theme:c?"dark":"base",themeVariables:{fontFamily:n["--codeFont"],primaryColor:n["--light"],primaryTextColor:n["--darkgray"],primaryBorderColor:n["--tertiary"],lineColor:n["--darkgray"],secondaryColor:n["--secondary"],tertiaryColor:n["--tertiary"],clusterBkg:n["--light"],edgeLabelBackground:n["--highlight"]}}),await r.run({nodes:e})}await o(),document.addEventListener("themechange",o),window.addCleanup(()=>document.removeEventListener("themechange",o));for(let n=0;n<e.length;n++){let v=function(){let g=l.querySelector("#mermaid-space"),m=l.querySelector(".mermaid-content");if(!m)return;y(m);let w=c.querySelector("svg").cloneNode(!0);m.appendChild(w),l.classList.add("active"),g.style.cursor="grab",u=new h(g,m)},M=function(){l.classList.remove("active"),u?.cleanup(),u=null},c=e[n],s=c.parentElement,a=s.querySelector(".clipboard-button"),d=s.querySelector(".expand-button"),p=window.getComputedStyle(a),L=a.offsetWidth+parseFloat(p.marginLeft||"0")+parseFloat(p.marginRight||"0");d.style.right=`calc(${L}px + 0.3rem)`,s.prepend(d);let l=s.querySelector("#mermaid-container");if(!l)return;let u=null;d.addEventListener("click",v),f(l,M),window.addCleanup(()=>{u?.cleanup(),d.removeEventListener("click",v)})}});
</script><script src="https://cdn.jsdelivr.net/npm/katex@0.16.11/dist/contrib/copy-tex.min.js" type="application/javascript"></script><script type="application/javascript">
        const socket = new WebSocket('ws://localhost:3001')
        // reload(true) ensures resources like images and scripts are fetched again in firefox
        socket.addEventListener('message', () => document.location.reload(true))
      </script><script src="../postscript.js" type="module"></script></html>